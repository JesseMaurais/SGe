Lux is an emitting C++ glue for Lua. This means that it exploits the C++
ability to generate functions at compile time. This happens whenever a 
templated function recieves a new argument type. Using this feature together
with a clever macro preprocessing step, Lux manages to greatly simplify the task
of exporting C functions to the Lua language. It is so simple that the user
need only learn one function to perform the most basic task.

	lux_function(vm, AnyFunction);

Where vm is a pointer to a valid lua_State. This 'function' is actually a macro
for the following

	#define lux_function(vm, fun) lux_register(vm, fun, #fun)

The latter being useful if you want Lua to refer to the function by another
name. This is really all you need to know to use Lux.

	lux_register(vm, YourFunction, "foobar");

If you are using C++11 or newer then you have access to lambda (anonymous)
functions which can generalise on the above register function

	#define lux_wrap(fun) [](lua_State *vm) { return lux_thunk(vm, fun); }

The above lux_thunk is a dispatching routine responsible for converting the Lua
stack values to the appropriate arguments for fun and pushing its return value,
if any. This way lux_wrap(fun) has the type lua_CFunction and can be used any
place in the Lua CAPI that asks for it. For example, you can pass it as the
CFunction in a luaL_Reg entry before a call to luaL_setfuncs. See test4.cpp
for an example doing this on a subset of the UNIX system API. 

Lux was designed to be minimalist and non intrusive. This means that you should
not have to modify any of your existing C/C++ code in order to give it to the
state machine. You do not need to write any "wrapper" functions to manipulate
the stack for C function calls (a lengthy process). Nor do you need to run an
external program that will parse your sources (an error prone process) to
generate extra sources files for your build (a cumbersome process). Everything
normally done by the user to export their native code is instead done by the
compiler itself during a two phase process. First, the macro preprocessor will
expand a number of codes in the C++ source files before it is sent to the
compiler proper. At this time the compiler semantics interpret the expanded
template functions on a per-use-basis. All of this is done on-the-fly at
compile time with no manual steps.

Since Lux relies heavily on templates, and templated functions are resolved at
compile time, the source can not be compiled into a library. So Lux is not a
library but rather a few useful headers. For this reason also, there is no
Makefile to build a library but there is a Makefile to build the test programs.

The most interesting header is lxsigma.hpp because it does the most work of
all, saving me what would have been hours of grinding out boring code.
It is basically a macro-function F with two arguments G and N, and it expands
every G from 0 to N. This macro is then used several times to generate many
functions of varying number and type of arguments. This process expands to
quite a length of code when all is done. You can check this by comparing the
file luxpand.hpp to lxthunk.hpp which is just the former that was preprocessed
with the -E option to g++

As given, N can be no greater than 9, which lets you export functions of up to
10 arguments with or without return values and with or without a class/object
attached to it. If for some reason you have functions with a crazy number of
arguments, you can edit the header yourself. Just add additional f# and g#
patterns after 9, then edit the expansion in luxpand.hpp to the higher number.

This macro-expanding trick, which I call sigma, is quite generally useful. For
example, one can fashion a class which will replace the C stdarg with something
much more type safe. Sigma requires that your C++ compiler be C99 capable, at
least insofar as it accepts the __VA_ARGS__ preprocessing symbol. However, the
Lux headers have been preprocessed so that you don't need to use sigma to use
them. You can go ahead with the Lux emitter without using sigma at all. 

Another header, lxstack.hpp is just alot of overhead, adding template signatures
to the common Lua functions. This is necessary for the way that the dispatching
routines work inside sigma. You may get errors emitting from lux_thunk when you
attempt to export functions that have arguments or return values that have not
been wrapped in this file with template signatures. They can be safely and
appropriately added to this file, or anywhere else in your own code, before
they are used in sigma.

Since the initial release additional features have been written that smooth
the Lua interface with C++ designs. A panic function that throws std::exception
transparently, and overloaded operator 'new' customed for garbage collection.
These are found in lxpanic.hpp and lxalloc.hpp respectively.

New in lxclass.hpp is dispatching functions that are methods of a class via the
metatable of userdata. This requires you alias your C++ types with some string
name that will be understood by the interpreter. The new state-based allocator
will call the constructor for a class and the garbage collector will call the
destructor for the same class. But all the memory allocation is done inside the
state machine.

Since many 3rd party libraries like SDL/OpenGL often take pointers to C style
data arrays, it became obvious that Lua needs simple C data manipulation. The
file lxarray.hpp contains code from the book "Programming in Lua" by Roberto
Ierusalimschy, modified with C++ templates to enhance its expressive power.
This allows user functions to receive array arguments with little trouble. For
emulating C data structures and unions, lxbytes.hpp is much like pythons pack
and unpack. It assigns keys to __index and __newindex table events that map to
functions which write POD to memory inside a C byte array at a given offset.

              *** THINGS THAT ARE KNOWN NOT TO WORK YET ***

Class constructors cannot take arguments from Lua because there is no C++
mechanism for reading their signatures (unlike functions). There is a potential
workaround for this. Pass the lua_State to the constructor so that it may
be parsed, but this is intrusive; against Lux design goals.

Traceback for debugging still does not work. I would like to have an error
reporting system print information on the console when a parse error occurs.

Sigma does not expand 'void' argument functions. These were written manually.

